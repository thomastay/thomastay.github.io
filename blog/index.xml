<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thomas Tay&#39;s blog</title>
    <link>https://ttay.me/blog/</link>
    <description>Recent content on Thomas Tay&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://ttay.me/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>I_made_x86_flags</title>
      <link>https://ttay.me/blog/i_made_x86_flags/</link>
      <pubDate>Sat, 06 Nov 2021 12:16:51 -0700</pubDate>
      
      <guid>https://ttay.me/blog/i_made_x86_flags/</guid>
      <description>This is going to be a tiny blog post to say that I&amp;rsquo;ve made a tiny site (microsite?) that&amp;rsquo;s all about x86 flags. I&amp;rsquo;m learning about x86 assembly, SIMD, and microarch these few weeks.
The eflags register is really confusing, so i made a tiny simulator to help me remember which flag is which. Particularly the carry and overflow flags, cos f**k whoever thought that was a good way to name their flags.</description>
    </item>
    
    <item>
      <title>Decompressing a gzip file by hand</title>
      <link>https://ttay.me/blog/gzip_investigations/</link>
      <pubDate>Sat, 16 Oct 2021 00:03:59 -0700</pubDate>
      
      <guid>https://ttay.me/blog/gzip_investigations/</guid>
      <description>Let&amp;rsquo;s make a gzipped file and see what&amp;rsquo;s in it. We&amp;rsquo;ll keep it simple: just write 8 &amp;lsquo;a&amp;rsquo;s to a file.
$ echo &amp;quot;aaaaaaaa&amp;quot; &amp;gt; test.out$ xxd test.out00000000: 6161 6161 6161 6161 0a aaaaaaaa.As we can see, our file is 9 bytes long. We have 8 &amp;lsquo;a&amp;rsquo; bytes written, plus a Line Feed (LF) character written at the end.
Let&amp;rsquo;s make the gzip file now. We&amp;rsquo;ll do gzip -1, since that will use the fastest compression mode and give us more things to talk about.</description>
    </item>
    
    <item>
      <title>Blub Framework Lifecycle</title>
      <link>https://ttay.me/blog/blub-framework-lifecycle/</link>
      <pubDate>Wed, 09 Jun 2021 19:09:23 -0700</pubDate>
      
      <guid>https://ttay.me/blog/blub-framework-lifecycle/</guid>
      <description>Warning: snark
 Blub framework is hacked together in a weekend. It is lean and mean, and solves all the problems of Blub domain. Pre-Blub users look at Blub, think it&amp;rsquo;s really cool but doesn&amp;rsquo;t have any libraries, so they pass. Blub framework is noticed by smart people, who begin building cool, interesting solutions with it. Blub now has its own website and learning guides. `${UNICORN_VIRAL_STARTUP}` adopts Blub, and now everyone pays attention.</description>
    </item>
    
    <item>
      <title>Brian Harry on Resource Management in .NET (2000)</title>
      <link>https://ttay.me/blog/brada_on_resource_management/</link>
      <pubDate>Mon, 17 Aug 2020 22:47:39 +0800</pubDate>
      
      <guid>https://ttay.me/blog/brada_on_resource_management/</guid>
      <description>The following email is written by Brian Harry and published by Brad Abrams (brada), written in 2000. It&amp;rsquo;s about the .NET runtime (C#, F#, VB), and why they decided to go with Garbage collection instead of sticking with reference counting. Worth a read if you&amp;rsquo;re interested in the debate between GC systems vs Ref Counted systems.
The question is all the more relevant these days (2020), with Ref Counted systems in vogue and GC out of fashion.</description>
    </item>
    
    <item>
      <title>Causal Messaging by example</title>
      <link>https://ttay.me/blog/causal_messaging/</link>
      <pubDate>Fri, 17 Jul 2020 12:00:00 +0800</pubDate>
      
      <guid>https://ttay.me/blog/causal_messaging/</guid>
      <description>When people first build a distributed system, they normally think of FIFO messaging, or maybe they build their system to be linearizable. But there&amp;rsquo;s an in-betweener, and that&amp;rsquo;s causal messaging.
Instead of giving you the definition, which is pretty mathematical, I&amp;rsquo;ll let you read it on your own, and I&amp;rsquo;ll give a real life example that you can hopefully grok.
Causal messaging is pretty important for some types of distributed systems.</description>
    </item>
    
    <item>
      <title>Pony actors don&#39;t have (their own) stacks</title>
      <link>https://ttay.me/blog/pony_actors_no_stacks/</link>
      <pubDate>Fri, 12 Jun 2020 12:00:00 +0800</pubDate>
      
      <guid>https://ttay.me/blog/pony_actors_no_stacks/</guid>
      <description>In this short article I&amp;rsquo;m going to talk about how Pony gets away with not storing a stack for each of its actors. I was pretty surprised to find this out, given that in most actor model languages actors have their own stacks. For instance, in Go, Goroutines have a stack size of 2KB. Elixir/Erlang processes have a 1.2KB combined stack and heap. But surprisingly, Pony&amp;rsquo;s actors don&amp;rsquo;t have their own stacks!</description>
    </item>
    
    <item>
      <title>Lessons learnt from optimizing a graph algorithm in F sharp</title>
      <link>https://ttay.me/blog/optimizing_graph_algo_fsharp/</link>
      <pubDate>Tue, 02 Jun 2020 22:12:51 -0600</pubDate>
      
      <guid>https://ttay.me/blog/optimizing_graph_algo_fsharp/</guid>
      <description>In this article I&amp;rsquo;m going to share how I optimized a graph algorithms interview question down from 58s down to 1.2s, nearly a 50x improvement! TLDR: Use the right data structures, exploit cache efficiency, and do less work.
For those unaware, F# is a functional-first language that runs on the .NET platform (think C#). Despite the title of the article, very little of the optimization techniques applies solely to F#, and so I have intentionally wrote this article to make it comprehensible even if you don&amp;rsquo;t understand a line of code in the article.</description>
    </item>
    
  </channel>
</rss>
